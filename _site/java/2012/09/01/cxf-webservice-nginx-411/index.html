
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>CXF webservice调用411 Length Required解决方案 &larr; </title>
   <meta name="author" content="JervyShi" />

   <link rel="start" href="/" />

	
	
	
  	<link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/feed JervyShi" title="RSS feed" />
	
	

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/assets/themes/mark-reid/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/assets/themes/mark-reid/css/screen.css" type="text/css" />

</head>
<body id="">
<div id="site">
  
  <div id="header">
    <h1>
    	<a href="/" title="JervyShi's Blog">JervyShi's Blog</a>
    	<span class="byline">&larr; <a href="/">JervyShi</a></span>
    </h1>
    <ul class="nav">
      <li><a class="home" href="/">Home</a></li>
      <li><a  href="/archive.html">Archive</a></li>
      <li><a  href="/pages.html">Pages</a></li>
      <li><a  href="/categories.html">Categories</a></li>
      <li><a  href="/tags.html">Tags</a></li>
    </ul>
  </div>

  
<div id="page">
	
  <h1 class="emphnext">CXF webservice调用411 Length Required解决方案</h1>
  <ul class="tag_box inline">
  
  


  
     
    	<li><a href="/tags.html#java-ref">java <span>1</span></a></li>
     
    	<li><a href="/tags.html#linux-ref">linux <span>1</span></a></li>
     
    	<li><a href="/tags.html#webservice-ref">webservice <span>1</span></a></li>
     
    	<li><a href="/tags.html#nginx-ref">nginx <span>1</span></a></li>
    
  



  </ul>

  <p>项目中一直用到<a href='http://cxf.apache.org/'>Apache CXF WebService</a>，原本服务端都是apache做转发，一切都很正常。有一天服务端换成nginx做转发，问题就出来了，客户端调用时抛出 411 Length Required 异常。</p>

<pre><code>javax.xml.ws.soap.SOAPFaultException: Response was of unexpected text/html ContentType.  
Incoming portion of HTML stream: &lt;html&gt;
&lt;head&gt;&lt;title&gt;411 Length Required&lt;/title&gt;&lt;/head&gt;
&lt;body bgcolor=&quot;white&quot;&gt;
&lt;center&gt;&lt;h1&gt;411 Length Required&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
	at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:146)
	at $Proxy53.testCXF(Unknown Source)</code></pre>

<p>根据异常的提示大致分析出异常应该是在客户端向服务端发出请求时请求头中不包含”<em>Content-length</em>”，尝试用空对象调用接口异常并未抛出，只有当List中超过一定量如50的bean之后会抛出此异常。据此分析apache cxf对不同数据量进行请求时并不是采用同种方式，为了方便分析不同数据量请求头的区别，我找到一台Linux用nc命令监控8080端口，并将客户端数据发送至此Linux上的8080端口。</p>

<pre><code># nc -l 8080</code></pre>

<p>第一步:使用小数据量进行测试，获取请求头如下，发现可以调用成功时cxf发送数据时请求头中包含”<em>Content-Length</em>”</p>

<pre><code>POST / HTTP/1.1
Content-Type: text/xml; charset=UTF-8
SOAPAction: &quot;&quot;
Accept: */*
User-Agent: Apache CXF 2.2.4
Cache-Control: no-cache
Pragma: no-cache
Host: 192.168.1.110:8080
Connection: keep-alive
Content-Length: 286</code></pre>

<p>第二步:使用大数据量进行测试，获取请求头如下，发现可以调用失败时cxf发送数据时请求头中没有包含”<em>Content-Length</em>”，同时多了一个”<em>Transfer-Encoding</em>”值为”chunked”，关于 的介绍可以参考博文<a href='http://www.51testing.com/?uid-390472-action-viewspace-itemid-233985'>http协议content-encoding &amp; transfer-encoding</a></p>

<pre><code>POST / HTTP/1.1
Content-Type: text/xml; charset=UTF-8
SOAPAction: &quot;&quot;
Accept: */*
User-Agent: Apache CXF 2.2.4
Cache-Control: no-cache
Pragma: no-cache
Host: 192.168.1.110:8080
Connection: keep-alive
Transfer-Encoding: chunked</code></pre>

<p>通过一番搜索，发现apache默认就是支持<em>chunked</em>块接收的，而nginx如果要支持这种格式必须要添加<em>chunkin-nginx-module</em>模块，但是给nginx添加新模块需要重新编译nginx，虽然能解决现有问题但是有必要通过一系列的测试等，需要找到一个更简单的临时解决方案。</p>

<p>既然apache cxf可以在请求头中添加”<em>Content-Length</em>”来发送并且数据量达到一定值之后会转换为<em>chunked</em>块发送，那么是否可以关掉chunked块发送方式呢，感觉apache cxf官网完善的文档，经过一番探索在<a href='http://cxf.apache.org/docs/client-http-transport-including-ssl-support.html'>Apahce cxf-User’s Guide</a>中找到了”<em>AllowChunking</em>”的设置，有两种方式，可以直接在代码中设置<em>AllowChunking</em>也可以在配置文件中设置<em>AllowChunking</em></p>

<pre><code>//Turn off chunking so that NTLM can occur
Client client = ClientProxy.getClient(port);
HTTPConduit http = (HTTPConduit) client.getConduit();
HTTPClientPolicy httpClientPolicy = new HTTPClientPolicy();
httpClientPolicy.setConnectionTimeout(36000);
httpClientPolicy.setAllowChunking(false);
http.setClient(httpClientPolicy);</code></pre>

<p>也可以在配置文件中设置</p>

<pre><code>&lt;http-conf:conduit name=&quot;{http://apache.org/hello_world_soap_http}SoapPort.http-conduit&quot;&gt;
  &lt;http-conf:client Connection=&quot;Keep-Alive&quot; MaxRetransmits=&quot;1&quot; AllowChunking=&quot;false&quot; /&gt;
&lt;/http-conf:conduit&gt;</code></pre>

<p>配置文件中”<em>http-conf:conduit</em>”的name设置格式是”<em>{WSDL Namespace}portName.http-conduit</em>”，但是这种方式经常由于搞错WSDL Namespace与portName而导致设置不生效，其实name还有一种设置格式是路径匹配，假如我是服务端提供了一个服务，服务地址是”<em>http://jervyshi.tk/services/userService?wsdl</em>”，这个时候name只需要配置为”<em>http://jervyshi.tk/.*</em>”即可拦截”<em>http://jervyshi.tk</em>”下的所有服务。</p>

<pre><code>&lt;http-conf:conduit name=&quot;http://jervyshi.tk/.*&quot;&gt;
	&lt;http-conf:client AllowChunking=&quot;false&quot; /&gt;
&lt;/http-conf:conduit&gt;</code></pre>
<ul class='posts'>
  
    <li><span>06 Apr 2013</span> &raquo; <a href='/2013/04/06/hello-jekyll'>Hello Jekyll</a></li>
  
    <li><span>01 Sep 2012</span> &raquo; <a href='/java/2012/09/01/cxf-webservice-nginx-411'>CXF webservice调用411 Length Required解决方案</a></li>
  
    <li><span>29 Dec 2011</span> &raquo; <a href='/lessons/2011/12/29/jekyll-introduction'>Jekyll Introduction</a></li>
  
</ul>

  <address class="signature">
    <a class="author" href="/">JervyShi</a> 
    <span class="date">01 September 2012</span>
    <span class="location"></span>
  </address>
  
  <div class="prev-next">
  
    <a href="/2013/04/06/hello-jekyll" class="next" title="Hello Jekyll">Next Post &rarr;</a>
  
  
    <a href="/lessons/2011/12/29/jekyll-introduction" class="prev" title="Jekyll Introduction">&larr; Earlier Post</a>
  
  </div>
  
</div><!-- End Page -->




  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'JervyShi'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>





  
  <div id="footer">
  	<address>
  		<span class="copyright">
  			Content by <a href="/info/site.html">JervyShi</a>. Design by 
  			<a href="http://mark.reid.name/">Mark Reid</a>
  			<br/>
  			Copyright 2012 - 2013 by <a href="http://jervyshi.me">JervyShi</a>			
  		</span>
  		<span class="engine">
  			Powered by <a href="http://github.com/mojombo/jekyll/">Jekyll</a> & <a href="http://pages.github.com/">GitHub</a>
  		</span>
  	</address>
  </div>
  
</div>

<!--[if IE 6]>
<script type="text/javascript"> 
	/*Load jQuery if not already loaded*/ if(typeof jQuery == 'undefined'){ document.write("<script type=\"text/javascript\"   src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js\"></"+"script>"); var __noconflict = true; } 
	var IE6UPDATE_OPTIONS = {
		icons_path: "http://static.ie6update.com/hosted/ie6update/images/"
	}
</script>
<script type="text/javascript" src="http://static.ie6update.com/hosted/ie6update/ie6update.js"></script>
<![endif]-->

  
</body>
</html>

